# -*- coding: utf-8 -*-
"""Copy of shamim

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jfaZzK_DnodS7jJvIJSH9_Nc6VhxnOna
"""

from googleapiclient.discovery import build
import sqlite3
from prettytable import PrettyTable
from googleapiclient.errors import HttpError

# API Key خود را اینجا جایگذاری کنید
api_key = 'AIzaSyCYPPzvy0QLjjuOq3LYL7iG5lbTbFBs7nU'
youtube = build('youtube', 'v3', developerKey=api_key)

# ساخت پایگاه داده و جدول
conn = sqlite3.connect('youtube_music_videos.db')
cursor = conn.cursor()

# حذف جدول قدیمی در صورت وجود و ساخت جدول جدید
cursor.execute('''DROP TABLE IF EXISTS videos''')
cursor.execute('''
CREATE TABLE IF NOT EXISTS videos (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT,
    link TEXT,
    instrument TEXT,
    channel TEXT,
    views INTEGER,
    duration TEXT,
    published_date TEXT,
    likes INTEGER,
    comments INTEGER,
    description TEXT,
    tags TEXT,
    thumbnail_url TEXT,
    category_id INTEGER,
    live_broadcast_content TEXT,
    default_audio_language TEXT,
    licensed_content BOOLEAN,
    definition TEXT,
    caption_status TEXT
)
''')

# جستجو در یوتیوب و ذخیره داده‌ها در پایگاه داده
def get_youtube_videos(query, instrument):
    try:
        request = youtube.search().list(
            q=query,
            part='snippet',
            type='video',
            maxResults=50
        )
        response = request.execute()

        for item in response['items']:
            title = item['snippet']['title']
            video_id = item.get('id', {}).get('videoId')
            channel_title = item['snippet'].get('channelTitle', 'Unknown')
            link = f"https://www.youtube.com/watch?v={video_id}" if video_id else 'N/A'
            published_date = item['snippet'].get('publishedAt', 'Unknown')
            description = item['snippet'].get('description', 'No description available')
            thumbnail_url = item['snippet'].get('thumbnails', {}).get('default', {}).get('url', 'N/A')
            live_broadcast_content = item['snippet'].get('liveBroadcastContent', 'none')

            # درخواست برای گرفتن اطلاعات بیشتر (مانند تعداد بازدید، لایک و غیره)
            if video_id:
                video_request = youtube.videos().list(
                    part='statistics,contentDetails,snippet',
                    id=video_id
                )
                video_response = video_request.execute()
                video_info = video_response['items'][0] if video_response['items'] else {}

                views = int(video_info.get('statistics', {}).get('viewCount', 0))
                likes = int(video_info.get('statistics', {}).get('likeCount', 0))
                comments = int(video_info.get('statistics', {}).get('commentCount', 0))
                duration = video_info.get('contentDetails', {}).get('duration', 'N/A')
                tags = ', '.join(video_info.get('snippet', {}).get('tags', []))
                category_id = int(video_info.get('snippet', {}).get('categoryId', 0))
                default_audio_language = video_info.get('snippet', {}).get('defaultAudioLanguage', 'Unknown')
                licensed_content = video_info.get('contentDetails', {}).get('licensedContent', False)
                definition = video_info.get('contentDetails', {}).get('definition', 'N/A')
                caption_status = 'available' if video_info.get('contentDetails', {}).get('caption', 'false') == 'true' else 'not available'
            else:
                views = 0
                likes = 0
                comments = 0
                duration = 'N/A'
                tags = 'N/A'
                category_id = 0
                default_audio_language = 'Unknown'
                licensed_content = False
                definition = 'N/A'
                caption_status = 'not available'

            # ذخیره اطلاعات در پایگاه داده
            cursor.execute(
                'INSERT INTO videos (title, link, instrument, channel, views, duration, published_date, likes, comments, description, tags, thumbnail_url, category_id, live_broadcast_content, default_audio_language, licensed_content, definition, caption_status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                (title, link, instrument, channel_title, views, duration, published_date, likes, comments, description, tags, thumbnail_url, category_id, live_broadcast_content, default_audio_language, licensed_content, definition, caption_status)
            )
        conn.commit()
    except HttpError as e:
        print(f"An HTTP error occurred: {e}")

# جستجوی ویدیوهای آموزشی مرتبط با پیانو و گیتار
get_youtube_videos('learn piano english', 'Piano')
get_youtube_videos('learn guitar english', 'Guitar')

# بازیابی داده از پایگاه داده و نمایش آن در قالب جدول
cursor.execute('SELECT * FROM videos')
videos = cursor.fetchall()

# ایجاد جدول برای نمایش داده‌ها
table = PrettyTable()
table.field_names = ["ID", "Title", "Link", "Instrument", "Channel", "Views", "Duration", "Published Date", "Likes", "Comments", "Description", "Tags", "Thumbnail URL", "Category ID", "Live Broadcast Content", "Default Audio Language", "Licensed Content", "Definition", "Caption Status"]

for video in videos:
    table.add_row([video[0], video[1], video[2], video[3], video[4], video[5], video[6], video[7], video[8], video[9], video[10], video[11], video[12], video[13], video[14], video[15], video[16], video[17], video[18]])

print(table)

# بستن ارتباط با پایگاه داده
conn.close()

from googleapiclient.discovery import build
import sqlite3
import matplotlib.pyplot as plt
from prettytable import PrettyTable
from googleapiclient.errors import HttpError
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import pandas as pd
import numpy as np
import seaborn as sns
import squarify

# API Key خود را اینجا جایگذاری کنید
api_key = ''AIzaSyCYPPzvy0QLjjuOq3LYL7iG5lbTbFBs7nU''
youtube = build('youtube', 'v3', developerKey=api_key)

# ساخت پایگاه داده و جدول
conn = sqlite3.connect('youtube_music_videos.db')
cursor = conn.cursor()

# حذف جدول قدیمی در صورت وجود و ساخت جدول جدید
cursor.execute('''DROP TABLE IF EXISTS videos''')
cursor.execute('''
CREATE TABLE IF NOT EXISTS videos (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT,
    link TEXT,
    instrument TEXT,
    channel TEXT,
    views INTEGER,
    duration TEXT,
    published_date TEXT,
    likes INTEGER,
    comments INTEGER,
    description TEXT,
    tags TEXT,
    thumbnail_url TEXT,
    category_id INTEGER,
    live_broadcast_content TEXT,
    default_audio_language TEXT,
    licensed_content BOOLEAN,
    definition TEXT,
    caption_status TEXT
)
''')

# جستجو در یوتیوب و ذخیره داده‌ها در پایگاه داده
def get_youtube_videos(query, instrument):
    try:
        request = youtube.search().list(
            q=query,
            part='snippet',
            type='video',
            maxResults=50
        )
        response = request.execute()

        for item in response['items']:
            title = item['snippet']['title']
            video_id = item.get('id', {}).get('videoId')
            channel_title = item['snippet'].get('channelTitle', 'Unknown')
            link = f"https://www.youtube.com/watch?v={video_id}" if video_id else 'N/A'
            published_date = item['snippet'].get('publishedAt', 'Unknown')
            description = item['snippet'].get('description', 'No description available')
            thumbnail_url = item['snippet'].get('thumbnails', {}).get('default', {}).get('url', 'N/A')
            live_broadcast_content = item['snippet'].get('liveBroadcastContent', 'none')

            # درخواست برای گرفتن اطلاعات بیشتر (مانند تعداد بازدید، لایک و غیره)
            if video_id:
                video_request = youtube.videos().list(
                    part='statistics,contentDetails,snippet',
                    id=video_id
                )
                video_response = video_request.execute()
                video_info = video_response['items'][0] if video_response['items'] else {}

                views = int(video_info.get('statistics', {}).get('viewCount', 0))
                likes = int(video_info.get('statistics', {}).get('likeCount', 0))
                comments = int(video_info.get('statistics', {}).get('commentCount', 0))
                duration = video_info.get('contentDetails', {}).get('duration', 'N/A')
                tags = ', '.join(video_info.get('snippet', {}).get('tags', []))
                category_id = int(video_info.get('snippet', {}).get('categoryId', 0))
                default_audio_language = video_info.get('snippet', {}).get('defaultAudioLanguage', 'Unknown')
                licensed_content = video_info.get('contentDetails', {}).get('licensedContent', False)
                definition = video_info.get('contentDetails', {}).get('definition', 'N/A')
                caption_status = 'available' if video_info.get('contentDetails', {}).get('caption', 'false') == 'true' else 'not available'
            else:
                views = 0
                likes = 0
                comments = 0
                duration = 'N/A'
                tags = 'N/A'
                category_id = 0
                default_audio_language = 'Unknown'
                licensed_content = False
                definition = 'N/A'
                caption_status = 'not available'

            # ذخیره اطلاعات در پایگاه داده
            cursor.execute(
                'INSERT INTO videos (title, link, instrument, channel, views, duration, published_date, likes, comments, description, tags, thumbnail_url, category_id, live_broadcast_content, default_audio_language, licensed_content, definition, caption_status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                (title, link, instrument, channel_title, views, duration, published_date, likes, comments, description, tags, thumbnail_url, category_id, live_broadcast_content, default_audio_language, licensed_content, definition, caption_status)
            )
        conn.commit()
    except HttpError as e:
        print(f"An HTTP error occurred: {e}")

# جستجوی ویدیوهای آموزشی مرتبط با پیانو و گیتار
get_youtube_videos('learn piano english', 'Piano')
get_youtube_videos('learn guitar english', 'Guitar')

# بازیابی داده از پایگاه داده و نمایش آن در قالب جدول
def display_videos():
    cursor.execute('SELECT * FROM videos')
    videos = cursor.fetchall()

    # ایجاد جدول برای نمایش داده‌ها
    table = PrettyTable()
    table.field_names = ["ID", "Title", "Link", "Instrument", "Channel", "Views", "Duration", "Published Date", "Likes", "Comments", "Description", "Tags", "Thumbnail URL", "Category ID", "Live Broadcast Content", "Default Audio Language", "Licensed Content", "Definition", "Caption Status"]

    for video in videos:
        table.add_row([video[0], video[1], video[2], video[3], video[4], video[5], video[6], video[7], video[8], video[9], video[10], video[11], video[12], video[13], video[14], video[15], video[16], video[17], video[18]])

    print(table)

def plot_statistics():
    cursor.execute('SELECT instrument, COUNT(*), SUM(views), AVG(likes) FROM videos GROUP BY instrument')
    data = cursor.fetchall()

    instruments = [row[0] for row in data]
    total_videos = [row[1] for row in data]
    total_views = [row[2] for row in data]
    avg_likes = [row[3] for row in data]

    # نمودار تعداد ویدیوها
    plt.figure(figsize=(10, 5))
    plt.bar(instruments, total_videos, color='blue')
    plt.xlabel('Instrument')
    plt.ylabel('Number of Videos')
    plt.title('Number of Videos per Instrument')
    plt.show()

    # نمودار تعداد بازدیدها
    plt.figure(figsize=(10, 5))
    plt.bar(instruments, total_views, color='green')
    plt.xlabel('Instrument')
    plt.ylabel('Total Views')
    plt.title('Total Views per Instrument')
    plt.show()

    # نمودار میانگین لایک‌ها
    plt.figure(figsize=(10, 5))
    plt.bar(instruments, avg_likes, color='red')
    plt.xlabel('Instrument')
    plt.ylabel('Average Likes')
    plt.title('Average Likes per Instrument')
    plt.show()

def plot_correlation_heatmap():
    cursor.execute('SELECT views, likes, comments FROM videos')
    data = cursor.fetchall()
    df = pd.DataFrame(data, columns=['Views', 'Likes', 'Comments'])

    plt.figure(figsize=(8, 6))
    sns.heatmap(df.corr(), annot=True, cmap='coolwarm', linewidths=0.5, linecolor='white')
    plt.title('Correlation Heatmap between Views, Likes, and Comments')
    plt.show()

def plot_pairplot():
    cursor.execute('SELECT views, likes, comments FROM videos')
    data = cursor.fetchall()
    df = pd.DataFrame(data, columns=['Views', 'Likes', 'Comments'])

    sns.pairplot(df, diag_kind='kde')
    plt.suptitle('Pair Plot of Views, Likes, and Comments', y=1.02)
    plt.show()

def plot_boxplot():
    cursor.execute('SELECT views, likes, comments FROM videos')
    data = cursor.fetchall()
    df = pd.DataFrame(data, columns=['Views', 'Likes', 'Comments'])

    plt.figure(figsize=(10, 6))
    sns.boxplot(data=df, palette='Set2')
    plt.title('Box Plot of Views, Likes, and Comments')
    plt.show()

def plot_views_over_time():
    cursor.execute('SELECT published_date, views FROM videos ORDER BY published_date')
    data = cursor.fetchall()
    df = pd.DataFrame(data, columns=['Published Date', 'Views'])
    df['Published Date'] = pd.to_datetime(df['Published Date'])

    plt.figure(figsize=(12, 6))
    sns.lineplot(x='Published Date', y='Views', data=df, color='blue')
    plt.title('Views Over Time')
    plt.xlabel('Published Date')
    plt.ylabel('Views')
    plt.xticks(rotation=45)
    plt.show()

def descriptive_statistics():
    # دریافت داده‌ها برای تحلیل آماری
    cursor.execute('SELECT views, likes, comments FROM videos')
    data = cursor.fetchall()
    df = pd.DataFrame(data, columns=['Views', 'Likes', 'Comments'])

    # محاسبه شاخص‌های آماری توصیفی
    print("\nDescriptive Statistics:\n")
    print(df.describe())

    # نمایش نمودارهای هیستوگرام برای توزیع داده‌ها
    df.hist(figsize=(10, 8), bins=20, color='skyblue')
    plt.tight_layout()
    plt.show()

def email_notification(email_address):
    # ارسال ایمیل به کاربر درباره ویدیوهای محبوب
    cursor.execute('SELECT title, link, views FROM videos WHERE views > 100000 ORDER BY views DESC LIMIT 5')
    popular_videos = cursor.fetchall()

    if not popular_videos:
        print("No popular videos found.")
        return

    message = MIMEMultipart()
    message['From'] = 'your_email@example.com'
    message['To'] = email_address
    message['Subject'] = 'Top 5 Popular Music Tutorial Videos'

    body = "Here are the top 5 popular music tutorial videos:\n\n"
    for video in popular_videos:
        body += f"Title: {video[0]}\nLink: {video[1]}\nViews: {video[2]}\n\n"

    message.attach(MIMEText(body, 'plain'))

    try:
        # تنظیمات SMTP
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login('your_email@example.com', 'your_password')
        server.send_message(message)
        server.quit()
        print("Email sent successfully!")
    except Exception as e:
        print(f"Failed to send email: {e}")

# اجرای برنامه در حالت متنی
while True:
    print("\nYouTube Music Video Analyzer")
    print("1. Display Videos")
    print("2. Plot Statistics")
    print("3. Descriptive Statistics")
    print("4. Correlation Heatmap")
    print("5. Pair Plot")
    print("6. Box Plot")
    print("7. Views Over Time")
    print("8. Send Email Notification")
    print("9. Exit")
    choice = input("Enter your choice: ")

    if choice == '1':
        display_videos()
    elif choice == '2':
        plot_statistics()
    elif choice == '3':
        descriptive_statistics()
    elif choice == '4':
        plot_correlation_heatmap()
    elif choice == '5':
        plot_pairplot()
    elif choice == '6':
        plot_boxplot()
    elif choice == '7':
        plot_views_over_time()
    elif choice == '8':
        email = input("Enter your email address: ")
        email_notification(email)
    elif choice == '9':
        break
    else:
        print("Invalid choice. Please try again.")

# بستن ارتباط با پایگاه داده
conn.close()

!pip install squarify
!pip install python-dotenv
!pip install reportlab

import os
from googleapiclient.discovery import build
import sqlite3
import matplotlib.pyplot as plt
from prettytable import PrettyTable
from googleapiclient.errors import HttpError
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import pandas as pd
import numpy as np
import seaborn as sns
# import squarify
import networkx as nx
from textblob import TextBlob
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import reportlab
from reportlab.pdfgen import canvas

# Set sensitive information directly
api_key = "AIzaSyCYPPzvy0QLjjuOq3LYL7iG5lbTbFBs7nU"
email_user = "YOUR_EMAIL_USER"
email_password = "YOUR_EMAIL_PASSWORD"

# Check if API key is available
if not api_key:
    raise ValueError("API Key is missing. Please set your YouTube API key.")

# YouTube API setup
youtube = build('youtube', 'v3', developerKey=api_key)

# Database setup
conn = sqlite3.connect('youtube_music_videos.db')
cursor = conn.cursor()

# Drop and recreate the videos table
cursor.execute('''DROP TABLE IF EXISTS videos''')
cursor.execute('''
CREATE TABLE IF NOT EXISTS videos (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT,
    link TEXT,
    instrument TEXT,
    channel TEXT,
    views INTEGER,
    duration TEXT,
    published_date TEXT,
    likes INTEGER,
    comments INTEGER,
    description TEXT,
    tags TEXT,
    thumbnail_url TEXT,
    category_id INTEGER,
    live_broadcast_content TEXT,
    default_audio_language TEXT,
    licensed_content BOOLEAN,
    definition TEXT,
    caption_status TEXT
)
''')

# Search and store videos in the database
def get_youtube_videos(query, instrument):
    try:
        request = youtube.search().list(
            q=query,
            part='snippet',
            type='video',
            maxResults=50
        )
        response = request.execute()

        for item in response['items']:
            title = item['snippet']['title']
            video_id = item.get('id', {}).get('videoId')
            channel_title = item['snippet'].get('channelTitle', 'Unknown')
            link = f"https://www.youtube.com/watch?v={video_id}" if video_id else 'N/A'
            published_date = item['snippet'].get('publishedAt', 'Unknown')
            description = item['snippet'].get('description', 'No description available')
            thumbnail_url = item['snippet'].get('thumbnails', {}).get('default', {}).get('url', 'N/A')
            live_broadcast_content = item['snippet'].get('liveBroadcastContent', 'none')

            # Sentiment analysis on description
            sentiment = TextBlob(description).sentiment.polarity

            # Fetch more details (views, likes, etc.)
            if video_id:
                video_request = youtube.videos().list(
                    part='statistics,contentDetails,snippet',
                    id=video_id
                )
                video_response = video_request.execute()
                video_info = video_response['items'][0] if video_response['items'] else {}

                views = int(video_info.get('statistics', {}).get('viewCount', 0))
                likes = int(video_info.get('statistics', {}).get('likeCount', 0))
                comments = int(video_info.get('statistics', {}).get('commentCount', 0))
                duration = video_info.get('contentDetails', {}).get('duration', 'N/A')
                tags = ', '.join(video_info.get('snippet', {}).get('tags', []))
                category_id = int(video_info.get('snippet', {}).get('categoryId', 0))
                default_audio_language = video_info.get('snippet', {}).get('defaultAudioLanguage', 'Unknown')
                licensed_content = video_info.get('contentDetails', {}).get('licensedContent', False)
                definition = video_info.get('contentDetails', {}).get('definition', 'N/A')
                caption_status = 'available' if video_info.get('contentDetails', {}).get('caption', 'false') == 'true' else 'not available'
            else:
                views = 0
                likes = 0
                comments = 0
                duration = 'N/A'
                tags = 'N/A'
                category_id = 0
                default_audio_language = 'Unknown'
                licensed_content = False
                definition = 'N/A'
                caption_status = 'not available'

            # Store video information in the database
            cursor.execute(
                'INSERT INTO videos (title, link, instrument, channel, views, duration, published_date, likes, comments, description, tags, thumbnail_url, category_id, live_broadcast_content, default_audio_language, licensed_content, definition, caption_status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                (title, link, instrument, channel_title, views, duration, published_date, likes, comments, description, tags, thumbnail_url, category_id, live_broadcast_content, default_audio_language, licensed_content, definition, caption_status)
            )
        conn.commit()
    except HttpError as e:
        print(f"An HTTP error occurred: {e}")

# Enhanced analysis and visualization
def plot_network_between_channels():
    cursor.execute('SELECT channel, tags FROM videos')
    data = cursor.fetchall()
    G = nx.Graph()
    for channel, tags in data:
        tags_list = tags.split(', ')
        for tag in tags_list:
            G.add_edge(channel, tag)
    plt.figure(figsize=(12, 8))
    nx.draw(G, with_labels=True, node_color='lightblue', font_size=10, node_size=500, edge_color='gray')
    plt.title('Network of Channels and Tags')
    plt.show()

def create_pdf_report():
    cursor.execute('SELECT title, views, likes, comments FROM videos ORDER BY views DESC LIMIT 10')
    popular_videos = cursor.fetchall()
    pdf_filename = "youtube_report.pdf"
    c = canvas.Canvas(pdf_filename)
    c.drawString(100, 800, "Top 10 YouTube Videos by Views")
    y = 780
    for video in popular_videos:
        c.drawString(100, y, f"Title: {video[0]}, Views: {video[1]}, Likes: {video[2]}, Comments: {video[3]}")
        y -= 20
    c.save()
    print(f"PDF report created: {pdf_filename}")

def predict_popularity():
    cursor.execute('SELECT views, likes, comments FROM videos')
    data = cursor.fetchall()
    df = pd.DataFrame(data, columns=['Views', 'Likes', 'Comments'])
    X = df[['Likes', 'Comments']]
    y = df['Views']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    model = LinearRegression()
    model.fit(X_train, y_train)
    predictions = model.predict(X_test)
    mse = mean_squared_error(y_test, predictions)
    print(f"Mean Squared Error of the model: {mse}")

# User input for search queries
instrument = input("Enter the instrument to search for (e.g., Piano, Guitar): ")
query = input(f"Enter the search query for {instrument}: ")
get_youtube_videos(query, instrument)

# Menu for enhanced features
while True:
    print("\nEnhanced YouTube Music Video Analyzer")
    print("1. Display Videos")
    print("2. Plot Network of Channels and Tags")
    print("3. Create PDF Report of Top Videos")
    print("4. Predict Video Popularity")
    print("5. Exit")
    choice = input("Enter your choice: ")

    if choice == '1':
        cursor.execute('SELECT * FROM videos')
        videos = cursor.fetchall()
        table = PrettyTable()
        table.field_names = ["ID", "Title", "Link", "Instrument", "Channel", "Views", "Duration", "Published Date", "Likes", "Comments"]
        for video in videos:
            table.add_row([video[0], video[1], video[2], video[3], video[4], video[5], video[6], video[7], video[8], video[9]])
        print(table)
    elif choice == '2':
        plot_network_between_channels()
    elif choice == '3':
        create_pdf_report()
    elif choice == '4':
        predict_popularity()
    elif choice == '5':
        break
    else:
        print("Invalid choice. Please try again.")

# Close the database connection
conn.close()